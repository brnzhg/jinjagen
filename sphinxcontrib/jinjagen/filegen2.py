from __future__ import annotations
from typing import NewType, Protocol, Callable, TypeVar, Generic, Mapping, Any, List, Dict, Tuple, Optional, Iterable, Sequence, Generator, Iterator
from typing import ForwardRef
from typing import cast

from collections import deque
from pathlib import Path
from enum import Enum

from dataclasses import dataclass

from jinja2 import Template
from jinja2.sandbox import SandboxedEnvironment
# from sphinx.application import Sphinx
# from sphinx.util.osutil import ensuredir
from sphinx.util.logging import getLogger
from sphinx.jinja2glue import BuiltinTemplateLoader
from .util import JinjaEnvFactory

from .node import StrKeyNodeBase, StrKeyNodeBaseP, StrKeyRootNodes, NodeFactory, LookupElseCreateNode

logger = getLogger(__name__)

#TODO make generic tree, lookup keys in one in other
@dataclass
class GenKeyNode(StrKeyNodeBase):
    _key: str
    _children: Dict[str, GenKeyNode]

    @property
    def key(self) -> str: return self._key

    @property
    def children(self) -> Dict[str, GenKeyNode]: return self._children

    @classmethod
    def from_children_iter(self, key: str, children: Iterable[GenKeyNode]) -> GenKeyNode:
        return GenKeyNode(key, {c.key: c for c in children})


@dataclass
class GenKeyRoots(StrKeyRootNodes[GenKeyNode]):
    pass



class FileGenRunNameOption(Enum):
    ALL_KEYS_DIRS = 1,
    ALWAYS_PREPEND_LAST_KEY = 2,
    PREPEND_LAST_KEY_FOR_SINGLE_ENTRY = 3


@dataclass
class FileGenRunDef:
    gen_key_roots: GenKeyRoots
    name: str
    template_filepath: str
    suffix: str
    name_option: FileGenRunNameOption
    base_dir_override: Optional[str]

    def entry_filepath_from_key_path(self, 
        has_siblings: bool, 
        base_dir: str, 
        from_root_keypath: List[str]) -> Path:
        # return Path(base_dir, *from_root_keypath, f'{self.name}.{self.suffix}')
        dirs_to_use: Iterable[str]
        filename_to_use: str
        if from_root_keypath \
            and (self.name_option == FileGenRunNameOption.ALWAYS_PREPEND_LAST_KEY \
                or (self.name_option == FileGenRunNameOption.PREPEND_LAST_KEY_FOR_SINGLE_ENTRY \
                    and not has_siblings)):
            dirs_to_use = from_root_keypath[:-1]
            filename_to_use = f'{from_root_keypath[-1]}_{self.name}'
        else:
            dirs_to_use = from_root_keypath
            filename_to_use = self.name

        base_dir_to_use = self.base_dir_override or base_dir
        return Path(base_dir_to_use, *dirs_to_use, filename_to_use)


    def create_run_data(self, template_env: SandboxedEnvironment) -> FileGenRunData:
        return FileGenRunData(self, template_env.get_template(self.template_filepath))



@dataclass
class FileGenRunData:
    run_def: FileGenRunDef
    template: Template

@dataclass
class FileGenNode(StrKeyNodeBaseP):
    _key: str
    _parent: Optional[FileGenNode]
    _children: Dict[str, FileGenNode]
    _run_entry_by_name: Dict[str, FileGenRunEntry]

    @property
    def key(self) -> str: return self._key

    @property
    def children(self) -> Dict[str, FileGenNode]: return self._children

    @property
    def parent(self) -> Optional[FileGenNode]: return self._parent

    @property
    def run_entry_by_name(self) -> Dict[str, FileGenRunEntry]: 
        return self._run_entry_by_name

@dataclass
class FileGenRoots(StrKeyRootNodes[FileGenNode]):
    pass

# take out of tree, just needed for context, should be generated by Node and Run, for each key
@dataclass
class FileGenRunEntry:
    # name: str
    gen_key: str
    run_data: FileGenRunData # same for all entries under same name
    filepath: Path # can be calculated, run output_dir + parent parent parent to root, combine gen_keys


# def create_file_gen_run_entry(src_dir: str,
#                               run: FileGenRunDef, 
#                               from_root_keys: List[str]) -> FileGenRunEntry:
#    run_entry_path: Path = Path(src_dir, *from_root_keys, f'{run.name}.{run.suffix}')
#    return FileGenRunEntry(run, run_entry_path)


@dataclass
class FileGenBuilderNode(StrKeyNodeBaseP):
    _key: str
    _parent: Optional[FileGenBuilderNode]
    _children: Dict[str, FileGenBuilderNode]
    _runs: List[FileGenRunData]

    @property
    def key(self) -> str: return self._key

    @property
    def children(self) -> Dict[str, FileGenBuilderNode]: return self._children

    @property
    def parent(self) -> Optional[FileGenBuilderNode]: return self._parent

    @property
    def runs(self) -> List[FileGenRunData]:
        return self._runs

    def gen_run_entries_by_name(self, base_dir: str) -> Dict[str, FileGenRunEntry]:
        has_siblings: bool = len(self.runs) > 1
        rs: Dict[str, FileGenRunEntry] = {}
        for r in self.runs:
            fgre: FileGenRunEntry = FileGenRunEntry(
                gen_key=self.key, 
                run_data=r, 
                filepath=r.run_def.entry_filepath_from_key_path(has_siblings, 
                    base_dir, 
                    list(self.from_root_keypath(include_self=True))))
            rs[r.run_def.name] = fgre
        return rs
        #lookup_file_node.run_entry_by_name[run_def.name] = FileGenRunEntry(
        #    gen_key=elt.key_node.key,
        #    run_data=run_data,
        #    filepath=run_def.entry_filepath_from_key_path(True,
        #                                                  src_dir,
        #                                                  lookup_file_node.from_root_keypath(include_self=True)))

    def build_file_gen_node(self, 
        base_dir: str, 
        build_parent: Optional[FileGenNode], 
        build_children: Dict[str, FileGenNode]) -> FileGenNode:
        rs = self.gen_run_entries_by_name(base_dir)
        return FileGenNode(self.key, build_parent, build_children, rs)



@dataclass
class FileGenBuilderRoots(StrKeyRootNodes[FileGenBuilderNode]):
    pass


@dataclass
class FileContext:
    gen_node: FileGenNode
    gen_roots: FileGenRoots
    gen_run_entry: FileGenRunEntry # dont need name, on FileGenEntry

    def get_render_kwargs(self) -> Dict[str, Any]:
        return {
            'gen_node': self.gen_node
            , 'gen_roots': self.gen_roots
            , 'gen_run_entry': self.gen_run_entry
        }

    def render(self) -> str:
        return self.gen_run_entry.run_data.template.render(self.get_render_kwargs())


class FileGenNodeFactory(NodeFactory[FileGenNode]):
    def __call__(self, key:str, parent:Optional[FileGenNode]) -> FileGenNode:
        return FileGenNode(key, parent, {}, {})

class FileGenBuilderNodeFactory(NodeFactory[FileGenBuilderNode]):
    def __call__(self, key:str, parent:Optional[FileGenBuilderNode]) -> FileGenBuilderNode:
        return FileGenBuilderNode(key, parent, {}, [])


def update_gen_builder_tree(
    gen_roots: FileGenBuilderRoots,
    run_data: FileGenRunData) -> None:
    @dataclass
    class GenBuilderTreeElt:
        src_node: GenKeyNode
        building_node: FileGenBuilderNode

    node_factory: FileGenBuilderNodeFactory = FileGenBuilderNodeFactory()
    q: deque[GenBuilderTreeElt] = \
        deque(GenBuilderTreeElt(root_key_node, gen_roots.lookup_else_create_node(root_key_node.key, node_factory)) \
            for root_key_node in run_data.run_def.gen_key_roots.roots.values())

    while q:
        elt: GenBuilderTreeElt = q.pop()

        if elt.src_node.children:
            for child_key_node in elt.src_node.children.values():
                child_building_node: FileGenBuilderNode = elt.building_node.lookup_else_create_node(child_key_node.key, node_factory)
                q.appendleft(GenBuilderTreeElt(child_key_node, child_building_node))
        else:
            elt.building_node.runs.append(run_data)


def update_gen_builder_tree_old(
    gen_roots: FileGenBuilderRoots, 
    run_data: FileGenRunData) -> None:
    @dataclass
    class UpdateGenBuilderTreeElt:
        node_builder: LookupElseCreateNode[FileGenBuilderNode]
        key_node: GenKeyNode

        def build_node(self, lookup_key: str) -> FileGenBuilderNode:
            return self.node_builder.lookup_else_create_node(lookup_key, FileGenBuilderNodeFactory())

    run_def: FileGenRunDef = run_data.run_def
    q: deque[UpdateGenBuilderTreeElt] = deque(UpdateGenBuilderTreeElt(
        gen_roots, key_node) for key_node in run_def.gen_key_roots.roots.values())

    while q:
        elt: UpdateGenBuilderTreeElt = q.pop()

        lookup_file_node: FileGenBuilderNode = elt.build_node(elt.key_node.key)
        if elt.key_node.children:
            for child_key_node in elt.key_node.children.values():
                q.appendleft(UpdateGenBuilderTreeElt(lookup_file_node, child_key_node))
        else:
            lookup_file_node.runs.append(run_data)
            #lookup_file_node.run_entry_by_name[run_def.name] = FileGenRunEntry(
            #    gen_key=elt.key_node.key,
            #    run_data=run_data,
            #    filepath=run_def.entry_filepath_from_key_path(True,
            #                                                  src_dir,
            #                                                  lookup_file_node.from_root_keypath(include_self=True)))


def build_tree(gen_builder_roots: FileGenBuilderRoots, base_dir: str) -> FileGenRoots:
    @dataclass
    class GenTreeElt:
        src_node: FileGenBuilderNode
        built_node: FileGenNode

    gen_roots: FileGenRoots = FileGenRoots({})
    q: deque[GenTreeElt] = deque()
    # deque(GenTreeElt(root_src_node, root_src_node.build_file_gen_node(base_dir, None, {})) \
    #        for root_src_node in gen_builder_roots.roots.values())

    for root_src_node in gen_builder_roots.roots.values():
        root_built_node: FileGenNode = root_src_node.build_file_gen_node(base_dir, None, {})
        gen_roots.add_node(root_built_node)
        q.appendleft(GenTreeElt(root_src_node, root_built_node))

    while q:
        elt: GenTreeElt = q.pop()

        for child_src_node in elt.src_node.children.values():
            child_built_node: FileGenNode = child_src_node.build_file_gen_node(base_dir, elt.built_node, {})
            elt.built_node.add_child(child_built_node)

            q.appendleft(GenTreeElt(child_src_node, child_built_node))

    return gen_roots


# TODO generate tree in two steps, first step mark everything out, second one create run entries with filepaths
# maybe create the tree without any entries, just nodes. Then add entries after
def gen_tree_from_runs(base_dir: str, runs: List[FileGenRunData]) -> FileGenRoots:
    gen_builder_roots: FileGenBuilderRoots = FileGenBuilderRoots({})

    for run_data in runs:
        update_gen_builder_tree(gen_builder_roots, run_data)

    return build_tree(gen_builder_roots, base_dir) 


def render_and_write_gen_node(
    gen_roots: FileGenRoots,
    gen_node: FileGenNode) -> None:
    for name, run_entry in gen_node.run_entry_by_name.items():

        # gen_node.children_by_gen_key

        # try:
        name_ctxt = FileContext(gen_node, gen_roots, run_entry)

        try:
            run_entry.filepath.parent.mkdir(exist_ok=True, parents=True)
            run_entry.filepath.write_text(name_ctxt.render())
        except Exception as ex:
            logger.error('wtf')
            raise ex
        # except Exception as ex:
        #   logger.error( 'Error %s'.format(format_exception(Exception, ex)))


def render_and_write_gen_tree(gen_roots: FileGenRoots) -> None:
    q: deque[FileGenNode] = deque(gen_roots.roots.values())

    # bfs
    while q:
        elmt = q.pop()
        render_and_write_gen_node(gen_roots, elmt)

        for elmt_child in elmt.children.values():
            q.appendleft(elmt_child)


def gen_from_run_defs(template_env: SandboxedEnvironment,
    run_defs: List[FileGenRunDef],
    src_dir: str) -> FileGenRoots:
    #get_template_env(app)

    # fetch run templates
    runs: List[FileGenRunData] = [run_def.create_run_data(template_env) for run_def in run_defs]

    # gen tree with output filepaths
    # assert app.env is not None
    gen_roots: FileGenRoots = gen_tree_from_runs(src_dir, runs)

    # str(app.env.srcdir)

    # render and write
    render_and_write_gen_tree(gen_roots)
    return gen_roots