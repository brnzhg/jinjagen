from __future__ import annotations
from typing import NewType, Protocol, Callable, TypeVar, Generic, Mapping, Any, List, Dict, Tuple, Optional, Iterable, Sequence, Generator, Iterator
from typing import ForwardRef
from typing import cast

from collections import deque
from pathlib import Path
from enum import Enum

from dataclasses import dataclass

from jinja2 import Template
from jinja2.sandbox import SandboxedEnvironment
from sphinx.application import Sphinx
# from sphinx.util.osutil import ensuredir
from sphinx.util.logging import getLogger
from sphinx.jinja2glue import BuiltinTemplateLoader

from .node import StrKeyNodeBase, StrKeyNodeBaseP, StrKeyRootNodes, NodeFactory, NodeFactoryReqP, LookupElseCreateNode

logger = getLogger(__name__)

#TODO make generic tree, lookup keys in one in other
@dataclass
class GenKeyNode(StrKeyNodeBase):
    _key: str
    _children: Dict[str, GenKeyNode]

    @property
    def key(self) -> str: return self._key

    @property
    def children(self) -> Dict[str, GenKeyNode]: return self._children

    @classmethod
    def from_children_iter(self, key: str, children: Iterable[GenKeyNode]) -> GenKeyNode:
        return GenKeyNode(key, {c.key: c for c in children})


@dataclass
class GenKeyRoots(StrKeyRootNodes[GenKeyNode]):
    pass



class FileGenRunNameOption(Enum):
    ALL_KEYS_DIRS = 1,
    ALWAYS_PREPEND_LAST_KEY = 2,
    PREPEND_LAST_KEY_FOR_SINGLE_ENTRY = 3


@dataclass
class FileGenRunDef:
    gen_key_roots: GenKeyRoots
    name: str
    template_filepath: str
    suffix: str
    name_option: FileGenRunNameOption
    base_dir_override: Optional[str]

    def entry_filepath_from_key_path(self, 
        has_siblings: bool, 
        base_dir: str, 
        from_root_keypath: List[str]) -> Path:
        # return Path(base_dir, *from_root_keypath, f'{self.name}.{self.suffix}')
        dirs_to_use: Iterable[str]
        filename_to_use: str
        if from_root_keypath \
            and (self.name_option == FileGenRunNameOption.ALWAYS_PREPEND_LAST_KEY \
                or (self.name_option == FileGenRunNameOption.PREPEND_LAST_KEY_FOR_SINGLE_ENTRY \
                    and not has_siblings)):
            dirs_to_use = from_root_keypath[:-1]
            filename_to_use = f'{from_root_keypath[-1]}_{self.name}'
        else:
            dirs_to_use = from_root_keypath
            filename_to_use = self.name

        base_dir_to_use = self.base_dir_override or base_dir
        return Path(base_dir_to_use, *dirs_to_use, filename_to_use)


    def create_run_data(self, template_env: SandboxedEnvironment) -> FileGenRunData:
        return FileGenRunData(self, template_env.get_template(self.template_filepath))




@dataclass
class FileGenRunData:
    run_def: FileGenRunDef
    template: Template

@dataclass
class FileGenNode(StrKeyNodeBaseP):
    _key: str
    _parent: Optional[FileGenNode]
    _children: Dict[str, FileGenNode]
    _run_entry_by_name: Dict[str, FileGenRunEntry]

    @property
    def key(self) -> str: return self._key

    @property
    def children(self) -> Dict[str, FileGenNode]: return self._children

    @property
    def parent(self) -> Optional[FileGenNode]: return self._parent

    @property
    def run_entry_by_name(self) -> Dict[str, FileGenRunEntry]: 
        return self._run_entry_by_name

@dataclass
class FileGenRoots(StrKeyRootNodes[FileGenNode]):
    pass

# take out of tree, just needed for context, should be generated by Node and Run, for each key
@dataclass
class FileGenRunEntry:
    # name: str
    gen_key: str
    run_data: FileGenRunData # same for all entries under same name
    filepath: Path # can be calculated, run output_dir + parent parent parent to root, combine gen_keys


# def create_file_gen_run_entry(src_dir: str,
#                               run: FileGenRunDef, 
#                               from_root_keys: List[str]) -> FileGenRunEntry:
#    run_entry_path: Path = Path(src_dir, *from_root_keys, f'{run.name}.{run.suffix}')
#    return FileGenRunEntry(run, run_entry_path)


@dataclass
class FileGenBuilderNode(StrKeyNodeBaseP):
    _key: str
    _parent: Optional[FileGenBuilderNode]
    _children: Dict[str, FileGenBuilderNode]
    _runs: List[FileGenRunData]

    @property
    def key(self) -> str: return self._key

    @property
    def children(self) -> Dict[str, FileGenBuilderNode]: return self._children

    @property
    def parent(self) -> Optional[FileGenBuilderNode]: return self._parent

    @property
    def runs(self) -> List[FileGenRunData]:
        return self._runs

    def gen_run_entries_by_name(self, base_dir: str) -> Dict[str, FileGenRunEntry]:
        has_siblings: bool = len(self.runs) > 1
        rs: Dict[str, FileGenRunEntry] = {}
        for r in self.runs:
            fgre: FileGenRunEntry = FileGenRunEntry(
                gen_key=self.key, 
                run_data=r, 
                filepath=r.run_def.entry_filepath_from_key_path(has_siblings, 
                    base_dir, 
                    list(self.from_root_keypath(include_self=True))))
            rs[r.run_def.name] = fgre
        return rs
        #lookup_file_node.run_entry_by_name[run_def.name] = FileGenRunEntry(
        #    gen_key=elt.key_node.key,
        #    run_data=run_data,
        #    filepath=run_def.entry_filepath_from_key_path(True,
        #                                                  src_dir,
        #                                                  lookup_file_node.from_root_keypath(include_self=True)))

    # def build_file_gen_node(self, src_dir: str) -> FileGenNode:
    #    rs = self.gen_run_entries_by_name(src_dir)
    #    return FileGenNode(self.key, self.p)



@dataclass
class FileGenBuilderRoots(StrKeyRootNodes[FileGenBuilderNode]):
    pass


@dataclass
class FileContext:
    gen_node: FileGenNode
    gen_roots: FileGenRoots
    gen_run_entry: FileGenRunEntry # dont need name, on FileGenEntry

    def get_render_kwargs(self) -> Dict[str, Any]:
        return {
            'gen_node': self.gen_node
            , 'gen_roots': self.gen_roots
            , 'gen_run_entry': self.gen_run_entry
        }

    def render(self) -> str:
        return self.gen_run_entry.run_data.template.render(self.get_render_kwargs())


# copied from autoapi - https://github.com/carlos-jenkins/autoapi/blob/master/lib/autoapi/sphinx.py
def get_template_env(app: Sphinx) -> SandboxedEnvironment:
    """
    Get the template environment.
    .. note::
       Template should be loaded as a package_data using
       :py:function:`pkgutil.get_data`, but because we want the user to
       override the default template we need to hook it to the Sphinx loader,
       and thus a file system approach is required as it is implemented like
       that.
    """
    #template_dir = [join(dirname(abspath(__file__)), 'templates')]
    template_loader = BuiltinTemplateLoader()
    template_loader.init(app.builder) # type: ignore
    template_env = SandboxedEnvironment(loader=template_loader)
    # template_env.filters['summary'] = filter_summary
    return template_env


class FileGenBuilderNodeFactory(NodeFactory[FileGenBuilderNode]):
    def __call__(self, key:str, parent:Optional[FileGenBuilderNode]) -> FileGenBuilderNode:
        return FileGenBuilderNode(key, parent, {}, [])

#TSrcNode = TypeVar('TSrcNode', bound=)
#T

#@dataclass
#class TreeBuilderElt(Generic[StrKeyNode]):
#    node_builder: 


def update_gen_builder_tree(
    gen_roots: FileGenBuilderRoots, 
    run_data: FileGenRunData) -> None:
    @dataclass
    class UpdateGenTreeElt:
        file_node_creator: LookupElseCreateNode[FileGenBuilderNode]
        key_node: GenKeyNode

        def get_file_node(self, lookup_key: str) -> FileGenBuilderNode:
            return self.file_node_creator.lookup_else_create_node(lookup_key, FileGenBuilderNodeFactory())

    run_def: FileGenRunDef = run_data.run_def
    q: deque[UpdateGenTreeElt] = deque(UpdateGenTreeElt(
        gen_roots, key_node) for key_node in run_def.gen_key_roots.roots.values())

    while q:
        elt: UpdateGenTreeElt = q.pop()

        lookup_file_node: FileGenBuilderNode = elt.get_file_node(elt.key_node.key)
        if elt.key_node.children:
            for child_key_node in elt.key_node.children.values():
                q.appendleft(UpdateGenTreeElt(lookup_file_node, child_key_node))
        else:
            lookup_file_node.runs.append(run_data)
            #lookup_file_node.run_entry_by_name[run_def.name] = FileGenRunEntry(
            #    gen_key=elt.key_node.key,
            #    run_data=run_data,
            #    filepath=run_def.entry_filepath_from_key_path(True,
            #                                                  src_dir,
            #                                                  lookup_file_node.from_root_keypath(include_self=True)))




# TODO generate tree in two steps, first step mark everything out, second one create run entries with filepaths
# maybe create the tree without any entries, just nodes. Then add entries after
def gen_tree_from_runs(base_dir: str, runs: List[FileGenRunData]) -> FileGenRoots:
    gen_builder_roots: FileGenBuilderRoots = FileGenBuilderRoots({})

    for run_data in runs:
        update_gen_builder_tree(gen_builder_roots, run_data)

    

    return gen_roots


def render_and_write_gen_node(
    gen_roots: FileGenRoots,
    gen_node: FileGenNode) -> None:
    for name, run_entry in gen_node.run_entry_by_name.items():

        # gen_node.children_by_gen_key

        # try:
        name_ctxt = FileContext(gen_node, gen_roots, run_entry)

        try:
            run_entry.filepath.parent.mkdir(exist_ok=True, parents=True)
            run_entry.filepath.write_text(name_ctxt.render())
        except Exception as ex:
            logger.error('wtf')
            raise ex
        # except Exception as ex:
        #   logger.error( 'Error %s'.format(format_exception(Exception, ex)))


def render_and_write_gen_tree(gen_roots: FileGenRoots) -> None:
    q: deque[FileGenNode] = deque(gen_roots.roots.values())

    # bfs
    while q:
        elmt = q.pop()
        render_and_write_gen_node(gen_roots, elmt)

        for elmt_child in elmt.children.values():
            q.appendleft(elmt_child)


def gen_from_run_defs(app: Sphinx, run_defs: List[FileGenRunDef]) -> FileGenRoots:
    template_env: SandboxedEnvironment = get_template_env(app)

    # fetch run templates
    runs: List[FileGenRunData] = [run_def.create_run_data(template_env) for run_def in run_defs]

    # gen tree with output filepaths
    assert app.env is not None
    gen_roots: FileGenRoots = gen_tree_from_runs(str(app.env.srcdir), runs)

    # render and write
    render_and_write_gen_tree(gen_roots)
    return gen_roots